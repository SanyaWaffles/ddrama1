/* *******************************************************************
 *		base_player.zsc
 *
 *		Base player pawn Daytime Drama Class
 *
 *		As long as you attribute it to me in some
 *		way I don't mind people using this. Considering how much
 *		some people have caused an uproar over the lack of proper
 *		examples and the like.
 *
 *		Copyright Sanya K. C. Waffles 2013-2017
 *
 * ****************************************************************** */

enum EVoiceOverTypes
{
	VOX_None = -1,
	VOX_Normal = 0,
	VOX_Boss1,
	VOX_Boss2,
	VOX_Boss3,
	VOX_Ending,
};

Class DD_PlayerPawn : PlayerPawn
{
	Default
	{
		TeleFogSourceType "DD_TeleportFog";
		TeleFogDestType "DD_TeleportFog";
		
		Scale 0.12;
	}
	
	// is this even a thing we need?
	enum ETrollBloodColors
	{
		TROLL_BLOOD_OLIVE,
		TROLL_BLOOD_BRONZE,
		TROLL_BLOOD_COBALT,
		TROLL_BLOOD_MAX,
	};
	
	enum ERIPSoundObitTypes
	{
		RIP_Normal,
		RIP_FelixHet,
		RIP_DeepHurting,
		RIP_LowtaxLoser,
		RIP_Jeopardy,
	};

	
	bool startepisode;		// starting episode?
	bool heatseektoggle;	// Rocket Launcher Heatseek Toggle
	int trollbloodstage;	// Trollblood Device Stage
	int shoucounter;		// current genicdershou counter (general use)
	int cscenehold;			// Hmmm...
	int expandloop;			// Expand Count
	int onelinercount;		// One Liner Counter
	bool onelinerhit;		// One Liner Flag
	int onelinertype;		// One Liner Type
	int onelinercooldown;	// One Liner cooldown;
	int typeofrip;			// Type of high quality RIP
	int seconds;			// Seconds elapsed
	
	// Make a rubbery expanding noise
	void A_DDExpandDongStart()
	{
		A_PlaySound("generic/expanding", CHAN_BODY);
	}
	
	// Loop until you go big
	state A_DDExpandDongLoop()
	{
		expandloop++;
		
		return (expandloop >= DD_ENEMY_SCALECOUNT) ? ResolveState("ExpandFinish") : ResolveState(null);
	}
	
	// When you do go big, explode like a motherfuckin' mushroom cloud
	void A_DDExpandDongFin()
	{
		A_Explode(128, 144);
		A_DDSpawnLudicrousGibs();
	}
	
	// Throw actual giblets around
	void A_DDSpawnLudicrousGibs()
	{
		A_SpawnItemEx("DD_LudicrousGibsFx", flags:DDFL_AMMOFLAGSFX);
	}
	
	void DDFunc_PlayerDies()
	{
		A_NoBlocking();
		A_PlayerScream();
		A_SetRoll((roll + (RandomPick[PlayerRIP](-22, -11, 11, 22))), SPF_INTERPOLATE);
		A_SetPitch((pitch + (Random[PlayerRIP](1,5))), SPF_INTERPOLATE);
	}
	
	void DDFunc_PlayerDiesXTreem()
	{
		A_NoBlocking();
		A_XScream();
		A_SetRoll((roll + (randompick[DDPLAYER_ROLL](-22, -11, 11, 22))), SPF_INTERPOLATE);
		A_SetPitch((pitch + (random[DDPLAYER_PITCH](1,3))), SPF_INTERPOLATE);
		A_DDSpawnLudicrousGibs();
	}
	
	void A_DDPlayerDiesGoesBig()
	{
		DDFunc_PlayerDiesXTreem();
		A_PlaySound("world/barrelx", CHAN_BODY);
		A_Explode(128, 144);
	}
	
	// Perform High Quality RIPs
	void A_RIPProcess()
	{
		if (health <= 0 && CVar.FindCVar('dd_rip').GetBool())
		{
			if (seconds == 5)
			{
				typeofrip = Random(RIP_Normal, RIP_Jeopardy);
				
				if (typeofrip == RIP_FelixHet)
				{
					S_ChangeMusic("", 0, false, true);
					players[0].mo.A_Print("\cj[ OA ]        [ HET ]", 30, "BigFont");
					players[0].mo.A_PlaySound("epitaph/felixsafe", (DDPLAYER_BODYCHAN), DDPLAYER_RIPVOL, false, ATTN_NONE);
				}
				
				if (typeofrip == RIP_DeepHurting)
				{
					players[0].mo.A_Print("\cgDEEP HURTING", 15, "BigFont");
					players[0].mo.A_PlaySound("epitaph/deephurting", (DDPLAYER_BODYCHAN), DDPLAYER_RIPVOL, false, ATTN_NONE);
				}
				
				if (typeofrip == RIP_LowtaxLoser)
				{
					players[0].mo.A_Print("\cgloser", 2);
					players[0].mo.A_PlaySound("epitaph/lowtax", (DDPLAYER_BODYCHAN), DDPLAYER_RIPVOL, false, ATTN_NONE);
				}
				
				if (typeofrip == RIP_Jeopardy)
				{
					S_ChangeMusic("D_JEOPTL", 0, false, true);
					players[0].mo.A_Print("\cjYOU FUCKING IDIOT", 15, "BigFont");
					players[0].mo.A_PlaySound("epitaph/joelidiot", (DDPLAYER_BODYCHAN), DDPLAYER_RIPVOL, false, ATTN_NONE);
				}
				
				if (typeofrip == RIP_Normal)
				{
					players[0].mo.A_PlaySound("epitaph/main", (DDPLAYER_BODYCHAN), DDPLAYER_RIPVOL, false, ATTN_NONE);
				}
			}
			
			if (seconds == 9)
			{
				if (typeofrip == RIP_FelixHet)
				{
					S_ChangeMusic("D_FLXOVR", 0, false, true);
				}
			}
			
			seconds++;
			
			if (seconds > 30) seconds = 30;	// To prevent overflow
		}
		else
		{
			seconds = 0;	// just in case the player is resurrected.
		}
	}
	
	void A_NewPlayerPain()
	{
		String sanyapain;
		
		if (!CVar.FindCVar('dd_classicsanyavoice').GetBool())
			sanyapain = "*pain100";
		else
			sanyapain = "sanya/sarahpain";
		A_PlaySound(sanyapain, CHAN_6);
	}
	
	void A_OneLinerInit(int olt)
	{
		onelinercount = 150;
		if (olt > VOX_None && olt <= VOX_Ending)
			onelinertype = olt;
	}
	
	// Perform Voice One Liner Actions
	void A_OneLinerProcess()
	{
		if (onelinercount >= 150 && onelinercooldown <= 0 && health > 0)
		{
			onelinerhit = true;
			
			if (onelinertype == VOX_Normal)
			{
				String sanyavox;
				
				if (!CVar.FindCVar('dd_classicsanyavoice').GetBool())
					sanyavox = "sanya/annavoiceover";
				else
					sanyavox = "sanya/sarahvoiceover";
				
				players[0].mo.A_PlaySound(sanyavox, (DDPLAYER_VOICECHAN), 2.0, false, ATTN_NONE);
				onelinercooldown = 150;
			}
		}
		
		if (onelinerhit)
		{
		
			if (onelinercount > 0)
				onelinercount--;
			
			if (onelinercount <= 0)
			{
				onelinercount = 0;
				onelinertype = VOX_None;
				onelinerhit = false;
			}
		}
	}
	
	void PerSecondFunctions()
	{
		A_RIPProcess();
		A_OneLinerProcess();
	}
	
	override void BeginPlay()
	{
		if (!startepisode)
		{
			startepisode = true;
			heatseektoggle = false;
			trollbloodstage = 0;
		}
		expandloop = 0;
		
		Super.BeginPlay();
	}
	
	override void Tick()
	{
		// to avoid something going on with "voodoo dolls" not performing right
		// or the like. Since Daytime Drama doesn't support multiplayer, this
		// is more for the sake of completion, or if someone wants to
		// expand on it.
		if (!player || !player.mo || player.mo != self)
		{
			// Only perform the PlayerPawn functionality, nothing more...
			Super.Tick();
			return;	// bailing out...
		}
		
		// This is mainly here to do things on every ~second or so.
		// We use modulo to check if current tics can be divided by 35
		// If it can, execute PerSecond Functions
		// ----
		if (level.time % 35 == 0)
		{
			// any per-second functions go here
			PerSecondFunctions();
		}
		
		if (onelinercooldown > 0)
			onelinercooldown--;
			
		Super.Tick();	// call any PlayerPawn Tick functionality
	}
}

